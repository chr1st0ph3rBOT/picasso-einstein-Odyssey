import torch

# Import the model classes from your existing scripts
from artist_x_train import ArtistX
from artist_y_train import ArtistY

def test_interaction(text_to_test: str, model_x: ArtistX, model_y: ArtistY):
    """
    Tests the interaction between Y's encoder and X's decoder.
    """
    print("\n--- Starting Interaction Test ---")
    print(f"Original Text: '{text_to_test}'")

    # Ensure models are on the same device and in evaluation mode
    device = model_x.encoder.device
    model_x.eval()
    model_y.eval()

    with torch.no_grad():
        # --- Step 1: Y "draws" the image (generates a latent vector) ---
        print("1. Y is encoding the text into a latent vector (the 'image')...")
        
        # Tokenize the input text
        inputs = model_y.tokenizer(text_to_test, return_tensors='pt').to(device)
        
        # Use Y's encoder (which is a copy of X's) to create the latent vector
        latent_vector = model_y.encoder(inputs['input_ids'], attention_mask=inputs['attention_mask']).last_hidden_state
        print("✅ Latent vector generated by Y.")

        # --- Step 2: X "interprets" Y's image (decodes the latent vector) ---
        print("2. X is decoding the latent vector from Y to reconstruct the text...")
        
        # Use X's decoder to process the latent vector from Y
        output_logits = model_x.decoder(inputs_embeds=latent_vector, attention_mask=inputs['attention_mask']).logits
        
        # Find the most likely token IDs from the logits
        predicted_ids = torch.argmax(output_logits, dim=-1)
        
        # Decode the token IDs back into text
        reconstructed_text = model_x.tokenizer.decode(predicted_ids[0], skip_special_tokens=True)
        print("✅ Text reconstructed by X.")

    return reconstructed_text


if __name__ == '__main__':
    DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
    
    try:
        # --- Load the trained models ---
        print("Loading trained ArtistX model...")
        X = ArtistX()
        # Load the best weights you saved from training
        X.load_state_dict(torch.load("artist_x_best_model.pth"))
        X.to(DEVICE)
        print("✅ ArtistX loaded successfully.")
        
        print("\nLoading ArtistY and inheriting encoder from X...")
        Y = ArtistY()
        Y.load_encoder_from_x(X) # Y's encoder is now a copy of X's
        Y.to(DEVICE)
        print("✅ ArtistY prepared successfully.")
        
        # --- Run the test ---
        test_sentence = "a painter who remembers what he drew"
        result = test_interaction(test_sentence, X, Y)
        
        print("\n--- Test Result ---")
        print(f"Original Text:      '{test_sentence}'")
        print(f"Reconstructed Text: '{result}'")
        
        # Verify the result
        if test_sentence.strip() == result.strip():
            print("\n✅ SUCCESS: The reconstruction is perfect. The shared encoder works!")
        else:
            print("\n❌ FAILED: The reconstruction does not match.")

    except FileNotFoundError:
        print("\n[Error] The trained model file 'artist_x_best_model.pth' was not found.")
        print("Please run the `artist_x_train.py` script first to train and save the model.")